{/* prettier-ignore-start */}
---
title: 'Wedding Photo Sharing'
publishedAt: '2024-06-07'
summary: 'This project is a custom-built wedding photo sharing app, created for a friend‚Äôs wedding. Guests scanned QR codes at their tables to instantly upload photos, resulting in 91 memories from 212 visitors with zero downtime.'
link: 'ayserenas.dk'
githubRepoLink: 'https://github.com/gokm8/qr-wedding-snap'
---
{/* prettier-ignore-end */}

When my good friend Renas Demir was planning his wedding, he asked if I knew of
any service where guests could easily share their photos. Instead of pointing
him to an existing solution, I offered to build something custom for them. The
result was [www.ayserenas.dk](https://www.ayserenas.dk) - a simple web app where
guests could scan QR codes at their tables and instantly upload photos from
their phones.

![QR code placed on wedding table for guests to scan and upload photos](/blog/wedding-photo-sharing/QR-on-tables.jpg 'QR code on wedding table')

_Wedding tables with QR codes allowing guests to upload photos instantly_

## Results

The wedding day was a complete success:

- **212 guests** visited the website üì±
- **91 lovely memories** collected üì∏
- **1 happy bridal couple** ‚ù§Ô∏è

Zero downtime throughout the event. Guests aged 20-70 uploaded successfully
without help.

## What It Needed To Do

Before diving into code, I mapped out what the app needed to accomplish:

**Functional Requirements:**

| ID     | Description                                      |
| ------ | ------------------------------------------------ |
| `FR01` | Guests must be able to access via a QR code      |
| `FR02` | Guests must input name before uploading photos   |
| `FR03` | Guests must be able to upload multiple photos    |
| `FR04` | The system must validate file types (JPEG, etc.) |
| `FR05` | The system must enforce a 5MB max per photo      |
| `FR06` | The system must store photos securely            |
| `FR07` | The system must show name with each photo        |
| `FR08` | The couple must have access to a gallery         |
| `FR09` | The couple must receive email notifications      |

Most importantly, it needed to be fast, reliable, and simple enough for anyone
to use - whether they're 20 or 70 years old.

## How It Works

I built the app with Next.js 15, using React for the interface and Tailwind CSS
for styling. For the backend, I used PostgreSQL to store photo information and
Supabase Storage to host the actual images. This setup gave me fast loading
times and the ability to handle multiple uploads at once.

The tech stack included:

- **Next.js 15** for the web framework
- **React Hook Form & Zod** for handling uploads and validation
- **PostgreSQL & Prisma** for storing and querying photo metadata
- **Supabase Storage** for images
- **Nodemailer** for sending instant email notifications

### The Upload Flow

When a guest scans the QR code, here's what happens:

1. Land on the home page
2. Click to upload CTA
3. Enter their name
4. Select photos from phone
5. App validates files
6. Photos upload in parallel
7. Data saves to database
8. Couple gets instant email
9. Photos appear in gallery

The entire app runs on Vercel's serverless platform, which automatically scales
to handle many uploads at once - perfect for when everyone's taking photos
during the wedding.

### System Architecture

Here's how all the pieces fit together:

![System architecture diagram showing Next.js frontend, API routes, PostgreSQL database, and Supabase storage](/blog/wedding-photo-sharing/architecture.png 'System architecture diagram')

## Building the Upload System

The heart of the app is the upload endpoint. When photos come in, the system
processes them efficiently by handling multiple uploads at the same time. Each
photo gets a unique name, gets stored in Supabase, and its information is saved
to the database. Once everything's uploaded, an email fires off to the couple
with a preview of the new photos.

This parallel processing approach means that when guests upload several photos
at once, they don't have to wait for each one to finish before the next starts -
everything happens simultaneously, making the experience feel instant.

## The User Experience

I kept the interface simple and clean. The home page greets guests with a
welcoming photo and a clear call-to-action button.

![Wedding photo sharing app home page with welcome message and upload button](/blog/wedding-photo-sharing/home-page.png 'Home page with call-to-action button')

The upload page has just two things: a field for their name and a button to
select photos. Behind the scenes, it checks that files are the right type and
not too large.

![Photo upload page showing name input field and file selection with validation](/blog/wedding-photo-sharing/upload-page.png 'Upload page with form validation')

For the couple, there's a private gallery showing all uploaded photos in a grid
layout, with each guest's name displayed alongside their contributions.

![Photo gallery displaying uploaded wedding photos in a responsive grid with guest names](/blog/wedding-photo-sharing/gallery-page.png 'Gallery page with uploaded photos')

_The gallery displays all wedding photos with guest names in a clean, responsive
grid_

## Staying in the Loop

Every time a guest uploads photos, the couple gets an email showing who
uploaded, how many photos, and small preview thumbnails. This way, even during
the busy wedding day, they can see the memories being captured in real-time.

![Email notification showing newly uploaded photos with guest name and thumbnails](/blog/wedding-photo-sharing/email-notification.gif 'Real-time email notification with photo previews')

## Wrapping Up

Building this app taught me that sometimes the best solutions are the simplest
ones. By focusing on making photo uploads effortless, the app just worked - no
complicated instructions needed, no technical support required on the wedding
day.

The combination of Next.js, Prisma, and Supabase gave me everything I needed to
build something reliable and fast. But the best part? Seeing friends celebrate
their special day while your code quietly works in the background, capturing
memories.
